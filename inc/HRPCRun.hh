// Your (thread local) run global data: an instance of this object will be 
// automatically generated by the RunManager (for each worker thread) by calling 
// your RunAction::GenerateRun interface method. At the end of the Run, these 
// (thread local) Run global intances will be merged a global intance (the one 
// that belongs to the Master RunManager), according to your implementation of 
// the Merge interface method.
// The appropriate (thread local) instance of this object will be available/
// obtainable in the appropriate (also thread local) EventAction Begin- and 
// End-OfEventAction interface methods where the (thread local) object will be 
// populated by data from at the end of each events.

#ifndef MYBOXRUN_HH
#define MYBOXRUN_HH

#include "G4Run.hh"

//modif			#include "HistoManager.hh"

// forward declarations
class MyBOXDetectorConstruction;
class MyBOXPrimaryGeneratorAction;

//root class

class TFile;
class TH1D;
class TH2D;
class TH3D;
class TTree;
class TNtuple;
class TGraph;

class MyBOXRun : public G4Run {

  // Method declaration:
  public:
    
    // CTR: 
	MyBOXRun(MyBOXDetectorConstruction* det, MyBOXPrimaryGeneratorAction* prim);
	virtual ~MyBOXRun();

    // Virtual method to be implemented to define the way of merging the underlying 
    // (thread local) Run global data structures into one global instance.
    virtual void Merge(const G4Run*);

   
    // Method to be called by the Master to compute final quantities using the 
    // its run global Run object into which all thread local run global run 
    // object instance has already been merged
    void  EndOfRunSummary();



    void AddTotalParticleInPerEvent( G4int n_incidenti_final)   {
    	fn_incidenti_final  += n_incidenti_final;
        }

    void AddParticleInTopPerEvent( G4int n_incidenti_top_final)   {
    	fn_incidenti_top_final  += n_incidenti_top_final;
            }

    void AddParticleInBotPerEvent( G4int n_incidenti_bot_final)   {
    	fn_incidenti_bot_final  += n_incidenti_bot_final;
            }

    void AddTotalChargePerEvent( G4int n_cariche_final)   {
    	fn_cariche_final  += n_cariche_final;
                }

    void AddGap1ChargePerEvent( G4int n_cariche_gap1_final)   {
    	fn_cariche_gap1_final  += n_cariche_gap1_final;
                }

    void AddGap2ChargePerEvent( G4int n_cariche_gap2_final)   {
        	fn_cariche_gap2_final  += n_cariche_gap2_final;
                    }


  // Data member declarations:
  private:
    
    	// data members to obtain some information needed at the end for the summary
    	// Note: that the PrimaryGeneratorAction is not set to the master's RunAction
    	//       so it will be nullptr for the master's YourRun. We will set it in
    	//       the Merge.
    	MyBOXDetectorConstruction*    fMyBOXDetector;
    	MyBOXPrimaryGeneratorAction*  fMyBOXPrimary;

    	//
      	// Run global data members:
      	// - sum of the energy deposit (charged track length) in the target per event


    	//G4long fTime;				//conta tempo per eseguire run

        G4int     fn_incidenti_final;				// contatore particelle incidenti bot + top
        G4int     fn_incidenti_top_final;			// contatore particelle incidenti top
        G4int     fn_incidenti_bot_final;			// contatore particelle incidenti bot

        G4int     fn_cariche_final;					// contatore particelle cariche in gap 1 + gap2
        G4int  	  fn_cariche_gap1_final;			// contatore particelle cariche in gap1
        G4int     fn_cariche_gap2_final;			// contatore particelle cariche in gap2

};

#endif
